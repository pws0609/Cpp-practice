다시 풀어볼 중요한 문제
 이분 탐색: 43, 44번
 DFS: 65번(이후 vector PAIR 선언법 공부하기), 66번, 68번
 BFS: 70번
 priority queue: 75번 못풀고 넘김
 크루스칼 알고리즘: 78번 못풀고 넘김

정렬
62 병합:	39번 어레이 병합 알것.
		전체를 divide 해주고 두 어레이씩 conquer 해준다. (둘 비교 끝나고 남은쪽 다 넣어주기 유의)
		conquer 결과를 tmp에 저장하고 tmp 정렬 끝나면 원래 array로 밀어넣는다.

230405
1,3 sol.	temp->a (temp가 가리키는 a)
	temp.a (temp의 a)
2 sol.	array 값은 포인터 형식으로 함수로 넘겨서 그냥 바꾸면 된다.
	array 자체가 주소값이기 때문.

230406
	inline 함수: 전역변수에서 선언함과 동시에 정의되며 함수 실행시간이 함수 호출시간보다 극단적으로 짧을때 시간 줄이기 위해 사용
	오버로딩: 이름 똑같은 함수 여러개
	오버라이딩: 새로운 함수로 덮어쓰기
	template: 5색펜이라고 생각. 여러가지 색(자료형)을 그때그때 필요할때 사용 가능
		오버로딩의 연장선
1.	default 매개변수: 함수 선언시 매개변수를 함께 선언하면 함수 호출에서 해당 변수 미입력 시 default 적용. 입력시 입력값 사용
2. ★	참조변수: 변수의 별명. 함수로 넘길때가 중요한데 넘겨진 원본 데이터 직접 수정이 가능하다.
		주소값&와 참조변수&는 다르다.
		함수 매개변수로 변수(int)를 넘겨주면 "값"을 넘기지만 참조변수(int&)를 넘겨주면 "본인"이 넘어가는 것이나 다름없다
	template: 5색펜이라고 생각. 여러가지 색(자료형)을 그때그때 필요할때 사용 가능
		오버로딩의 연장선

230411
6.	소수 구하기: 제곱근(sqrt)을 활용해 N의 제곱근 까지의 수의 약수만 구한다. 이후 해당 약수로 N을 나눠 반대값을 구한다.
	정수 판별법: int 로 강제형변환한 값을 뺀게 0인지 확인한다.

230412
7.	공백 입력받기: getline(cin, "string") <- 공백 포함 문자열
			cin.getline("string","len",'?') <- ? 입력시 입력 종료

230415
14.★	1은 소수가 아니다

230426
32.	선택 정렬: 맨 뒤부터 점검하고 그 앞의 모든 수를 점검하고 제일 큰 수와 swap (big-O(n^2))

230502
42.	vector: array와 같이 사용, push_back 사용가능

230509
43,44	이분 탐색의 중요한 것:
	mid 를 물어보는 것으로 설정하자.
	count 함수를 만들어 조건에 충족하는지 여부를 확인한다
	충족 여부에 따라 lt, rt, res를 수정한다.

230524
58.	DFS: 재귀함수로 구현. node를 방문하는 순서를 지정.

230527
62.	Merge sort

230603
68.	vector 활용 pair<int,int>로 메모리를 할당해주고 make_pair 혹은 { 1,1 } 구조체로 데이터 넣어줌.
	불러올땐 graph[a][b].first graph[a][b].second 로 불러옴